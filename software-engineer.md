# Что изучать?
- парадигмы программирования
- предметная область
- широкая техническая эрудиция
- абстрактное мышление
- коммуникативные способности

# Откуда брать
- у профессионала
- open source
- опыт в сложной предметной области
- смежные области знаний
- учить других

# На какие вопросы нужно стараться ответить?
- Почему так, а не иначе
- Научное осмысление паттернов и приемов

# Базовые знания

Отрасль | Область
--- | ---
Математика | Алгебра, логика, дискретная математика, теория категорий, графы, топология, теория множеств, вычислительная математика 
Электроника  | Аналоговая электроника, цифровая электроника, микроэлектроника, процессоры, полупроводники
Алгоритмы | Теория вычислений, абстрактная машина, архитектура Вона Ньюмана
Абстракции | Моделирование, системный анализ, контролируемые абстракции: функции, события, интерфейс; абстракции данных: переменная, структура, список, дерево, граф


# Парадигмы
* Императивная
  * Неструктурная
  * Структурная
    * Процедурная
      * Объектно-ориентированная и прототипная
* Декларативная
  * Функциональная
  * Логическая
 * Data-Driven
 * Generic          
  

  

1. Императивный подход - последовательный переход из одной части программы в другую. Алгоритмический подход. Переменные, циклы и условные переходы.
2. Функциональный подход - многие операции могут исполняться параллельно, нет переменных, не может быть циклов. Должны быть только функции и их аргументы. Вместо циклов рекурсия.
3. Неструктурный подход - assembler, basic, bash. Мы можем попасть в любую точку программы, у нас нет контекста. Все переменные - глобальные. Эти программы имеют максимальное быстродействие.
4. Структурный подход - есть контекст, человекопонятный.
5. Процедурный подход - разбитие на компоненты, которые могут друг друга вызывать.
6. Объектно-ориентированный подход - разделение программы на компоненты со своим состоянием и методы. Атрибуты и методы объединяются в классы.
7. Прототианый подход - то же, что и ООП, только вместо классов прототипы.
8. Декларативный - пример: Lisp. 
9. Логический подход.

# Техники

1. Асинхронная
2. Параллельная
3. ООП. Поведение смешивается с данными.
4. Визуальная.
5. Реактивная. Разные значения связаны друг с другом и передают другим значения.
6. Событийная. Не меняем состояние, передаем событие.
7. Метапрограммирование. Джейнерики, автоматическая генерация кода (одна программа пишет другую), когда программа модифицирует связи внутри себя.

# Области
- системное. Программист выпускает средство для программирования.
- прикладное

# Tasks

Задачу надо разбить на подзадачу и подобрать или изготовить инструмент для решения подзадач.

## Решение задач.

### Управление сложностью

- Модули. Имеет зависимости и экспортируют идентификаторы
- Слои. Это контракт. Имеет абстрактный уровень. Мы можем сами создавать эти слои
- Библиотеки. Библиотеки как отдельные файлы, библиотека можеты быть зависима от задачи.

### Состояние

Глобальный контекст. Нужно минимизировать, пытаться сократить область видимости. Состояние должно быть детерминировано.

### Архитектура

Разделение кода на части, имена, связывание.

# Преодоление комплексности

# Данные и логика

- Разделение. API + data structures, анемические модели - статические. CRUD. MVC, MVP, MVVP patterns.
- Комбинация. ООП, императивный, компонентный подходы.

# Разработка

- Логгирование и юзерские сценарии
- highload и масштабирование
- документирование. Если человек не понимает что написано, это выкидывается.

# Подходы

- можно начать с интерфейса
- можно начать с модели процессов
- можно начать с моделей данных

# NIH (not invented here)

- совместимость со всем миром
- оно более целостно, если вы один это спроектировали
- легко разобраться

# Софтина

- локальная
- сервисная
- client-side-application
- системнная. Субд, яп, ос и т.п.
- распределенная
- микропрограммирование. Контроллеры.

# Типы связывания

- Ч/з данные
- Ч/з вызов через определенный контракт
- Ч/з передачу событий или протоколов
